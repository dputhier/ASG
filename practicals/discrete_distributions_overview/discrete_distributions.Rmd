---
title: Discrete distributions for the analysis of Next Generation Sequencing (NGS)
  data
author: "Jacques van Helden"
date: 'First version: 2016-12-10; Last update: `r Sys.Date()`'
output:
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  html_document:
    fig_caption: yes
    highlight: zenburn
    self_contained: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
    toc_float: yes
  ioslides_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 5
    fig_width: 7
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_md: no
    slide_level: 2
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  slidy_presentation:
    fig_caption: yes
    fig_height: 6
    fig_width: 7
    highlight: tango
    incremental: no
    keep_md: no
    self_contained: yes
    slide_level: 2
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
font-import: http://fonts.googleapis.com/css?family=Risque
font-family: Garamond
transition: linear
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, cache = FALSE, message = FALSE, warning = FALSE,
                      comment = "")

## Options to display pretty numbers
library(knitr)
knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark=" ")
})
options(scipen = 6, digits = 3)

```


# Introduction

## Discrete probabilities and NGS

The advent of Next Generation Sequencing (**NGS**) technologies revived the importance of discrete distributions of probabilities for biologists. 

This tutorial aims at providing a rapid overview of some discrete distributions commonly used to analyse NGS data, and highlight the relationship between them. 

## Overview

| Distribution |  Applications |
|-----------------|-----------------------------------------------|
| Geometric | Local read mapping without mismatch (read extension until first mismatch) |
| Binomial | Global read mapping with a given number of mismatches |
| Negative binomial | Local read mapping with $m$ mismatches (waiting time for $(m+1)^{th}$ mismatch); <br> Detection of differentially expressed genes from RNA-seq data |
| Poisson | ChIP-seq peak calling |
| Hypergeometric | Enrichment of a set of differentially expressed genes for functional classes |

****************************************************************
# Perfect match probability

## Perfect match probability

We align a library of 50 million short reads of 25 base pairs onto a genome that comprises 23 chromosomes totalling 3 Gigabases. 

For the sake of simplicity, we assume that nucleotides are equiprobable and independently distributed in the genome.

What is the probability to observe the following events by chance?

a. A perfect match for a given read at a given genomic position.
b. A perfect match for a given read anywhere in the genome (searched on two strands).
c. A perfect match for any read of the library at any position of the genome.

d. How many matches do we expect by chance if the whole library is aligned onto the whole genome?

## Perfect match - parameters

Let us define the variables of our problem.
Since we assume equiprobable and independent nucleotides we can define $p$ as probability to observe a match by chance for a given nucleotide.

$$p = P(A) = P(C) = P(G) = P(T) = 0.25$$


```{r perfect_match_parameters}
k <- 25    # Read length
L <- 50e6  # Library size
C <- 23    # Number of chromosomes
G <- 3e9   # Genome size
p <- 1/4   # Matching probability for a nucleotide
```

**Exercise:** use these parameters to compute the matching probability for a read (*solution is on next slide*).

## Perfect match for a given read at a given genomic position

Since we assume independence, the joint probability (probability to match all the nucleotides) is the product of the individual matching probabilities for each nucleotide.


```{r perfect_match_solution}
# Matching probabilty for a given read 
# at a given genomic position
P.read <- p^k  
```

$$P_{\text{read}} = P(n_1 \land n_2 \land \ldots \land n_k) = p^k = `r p`^{`r k`} = `r signif(digits=2, p^k)`$$

This looks a rather small probability. However we need to take into account that this risk will be challenged many times: 

- the size of the genome (`r G`)
- the size of the sequencing library (`r L`)

## Number of genomic alignments

The read will be aligned to each genomic position, but we should keep in mind the following facts. 

1. For each chromosome, we will skip the last `r k-1` positions, since a `r k` bp read cannot be fully aligned there. 
2. We double the number of alignments since we try to map the read on two strands. 

$$N = 2 \sum_{i=1}^C (L_i - k + 1) = 2 \left( G - C (k - 1)  \right)$$

```{r number_of_alignments}
N <- 2 * (G - C * (k - 1))
```

In total, we will thus try to align each read on `r N` genomic positions. 


## Genome-wise matching probability for one read

We reason in 3 steps, by computing the following probabilities. 

| Formula | Rationale |
|---------------------|--------------------------------------------------------|
| $1 -P_{\text{read}}$ | no match at a given genomic position |
| $(1 -P_{\text{read}})^N$ | not a single match in the genome |
| $1 - (1 -P_{\text{read}})^N$ | at least one match in the genome |
| | |

```{r pm_one_read_any_position}
P.genomic <- 1 - (1 - P.read)^N
```

This gives $P_{\text{genomic}} = `r P.genomic`$.

## Library-wise probability

We can apply the same reasoning for the library-wise probability. 

| Formula | Rationale |
|-------------------------------|-------------------------------------------|
| $1 -P_{\text{genomic}} = (1 -P_{\text{read}})^G$ | no genomic match for a given read |
| $(1 -P_{\text{read}})^{G L}$ | not a single genomic match in the library |
| $1 - (1 -P_{\text{read}})^{G L}$ | at least one genomic match in the library |
| | |

```{r pm_any_read_any_position}
P.library <- 1 - (1 - P.read)^(G*L)
```

This gives $P_{\text{library}} = `r P.library`$, which should however not be literally interpreted as a certainty, but as a probability so close to $1$ that it cannot be distiguished from it. 

## Expected number of matches


The expected number of matches is the read matching probability mutliplie by the number of matching trials, i.e. $G \cdot L$ since each read will be matched against each genomic position.


$$E(X) = P_{read} \cdot N \cdot L$$

```{r expected_matches}
E <- P.read * N * L
```

In total, we expect `r E` perfect matches by chance for the whole library against the whole genome.

****************************************************************
# Geometric distribution: local alignment without mismatch

## Local alignment until the first mismatch

A local read-mapping algorithm starts by aligning the 5' base of a read, and extends the alignment until either the first mismatch or the end of the read. In the example below, the alignment stops after 11 nucleotides.

```
    ATGCG ACTAG CATAC GAGTG ACTAA
    11111 11111 10
... ATGCG ACTAG CGTTC GACTG ACTAA ...
```

What is the probability to obtain by chance:

a. an alignment of exactly $25$ nucleotides?
b. an alignment of at least $25$ nucleotides?

## Local alignment -- parameters


```{r local_no_mismatch}
p <- 0.25  # Matching probability for each nucleotide
x <- 25    # Number of matches before the first mismatch
P.x <- p^x * (1-p)
Pval.x <- p^x
```

$$P(X=`r x`) = p^x (1-p) = 0.25^{`r x`} 0.75 = `r P.x`$$

$$P(X \ge `r x`) = p^x = 0.25^{`r x`} = `r Pval.x`$$


## Geometric distribution


```{r geometric_densiy, echo=FALSE, fig.width=7, fig.height=4, fig.cap="**Geometric distribution.** "}
x <- 0:25  # Series of X values

# Geometric density function
P.x <- dgeom(x = x, prob = p)

# Geometric p-value distribution
Pval.x <- pgeom(q = x-1, prob = p, lower.tail = FALSE)

plot(x, P.x, type="h", lwd=2, col="#888888", ylim=c(0,1), las=1, panel.first=grid(), 
     xlab="Nucleotides before first mismatch", ylab="Probabilities")
lines(stepfun(x, c(1, Pval.x)), verticals=TRUE, col="darkgreen")
legend("topright", legend=c("Density: P(X=x)", "P-value: P(X>=x)"), col=c("#888888", "darkgreen"), lwd=2)
```


****************************************************************
# Binomial: global alignment with $m$ mismatches

## Global alignment with mismatches

What is the probability to observe a global alignment with at most $m=3$ mismatches for a given read of 25bp aligned on a particular genomic position?

This question can be formulated as a Bernoulli schema, where each nucleotide is a trial, which can result in either a success (nucleotide match between the read and the genome) or a failure (mismatch). We can label each position of the alignment with a Boolean value indicating whether it maches ($1$) or not ($0$), as examplified below. 

```
    ATGCG ACTAG CATAC GAGTG ACTAA
    11111 11111 10101 11011 11111
... ATGCG ACTAG CGTTC GACTG ACTAA ...
```

At each position, we have a probability of success $p=0.25$, and a probability of failure $q = 1-p = 0.75$.

## Probability to observe exactly $k$ matches

```{r}
n <- 25     # Number of trials, i.e. the length of the alignment
m <- 3      # Maximal number of accepted mismatches
k <- n -m   # Number of matches
p <- 1/4    # Matching probability for one nucleotide
```

Let us denote by $k$ the number of matching residues. 
The probability to observe $k$ successes in a Bernoulli schema with $n$ trials and 

$$P(X=k) = \mathcal{B}(k; n, p) = \binom{n}{k}p^k(1-p)^{n-k} = \frac{n!}{k!(n-k)!}p^k(1-p)^{n-k}$$

## Binomial and perfect match

**Remark**: the perfect match probability seen above is a particular case of the binomial. 

$$P(X=n) = \frac{n!}{n!0!}p^n(1-p)^{n-n} = p^n$$

## Probability of hit with at most $m$ mismatches

We can sum the probabilities for all possible values of matches from $k = n -m$ ($m$ mismatches) to $k = n$ (no mismatch).

$$P(M \le m) = \sum_{k=n-m}^{n} \binom{n}{k}p^k(1-p)^{n-k}$$

## Binomial density

```{r echo=FALSE, fig.height=4, fig.width=7, fig.cap="**Binomial density function**. Alignemnts with at most $m$ mismatches are highlighted in blue. "}
x <- 0:n  # All possible numbers of matches
m <- 3    # Max number of mismatches
hits <- (n-m):n # Hits: at least n-m matches
plot(x, dbinom(x, n, p), type="h", lwd=2, col="grey", 
     xlab="X matching nucleotides", ylab="P(X=x)")
lines(hits, dbinom(hits, n, p), type="h", lwd=2, col="blue")
arrows(n-m, 0.02, n, 0.02, length = 0.1, lwd=2, 
       code = 3, angle=20, col="blue")
```

## Binomial P-value

```{r echo=FALSE, fig.height=4, fig.width=7, fig.cap="**Binomial p-value**. The ordinate indicates the probability to obtain at least $x$ matching nucleotides by chance. "}
x <- 0:n  # All possible numbers of matches
m <- 3    # Max number of mismatches
hits <- (n-m):n # Hits: at least n-m matches
y <- pbinom(x-1, n, p, lower=FALSE)
plot(stepfun(x, c(1, y)), verticals = TRUE,
#plot(x+0.5, y, type="S", lwd=2,
     col="darkgreen", las=1, main="Binomial P-value", 
     xlab="X", ylab="P(X >= x)", log="y",
     panel.first = grid())
pval <- pbinom(n-m-1, n, p, lower=FALSE)
arrows(n-m, pbinom(n-1, n, p, lower=FALSE), n-m, pval, 
       angle = 0, length = 0.1, lwd=2, col="blue")
arrows(n-m, pval, 0, pval, 
       angle = 20, length = 0.1, lwd=2, col="blue")
text(0, 10*pval, 
     labels = paste("P(X >= ", n-m, ") = ", 
                    signif(digits=2, pval), sep=""), pos = 4, col="blue")
```

## Simulated sequences

We can generate random sequences with equiprobable and independent residues from the nucleotide alphabet. 

$$\mathcal{A} = \{A, C, G, T\}$$

```{r random_sequences, echo=FALSE}
# Generate random sequences with equiprobable residues
alphabet <- c("A", "C", "G", "T") # Nucleotide alphabet
n <- 25    # Size of the reads
rep <- 100000 # number of repetitions
# Generate random "sequeences" 
# (actually a matrix of letters)
seq <- data.frame(matrix(nrow=rep, ncol=n, sample(alphabet, size=n * rep, replace = TRUE)))

# Print the 5 first sequences to check result
cat(c(apply(seq[1:5,], 1, paste, collapse=""), "..."), sep="\n")
```

## Counting mismatches between read and random sequences

```{r count_matches, echo=FALSE}
## Count the number of matches between a random read 
## and random sequences of the same length

# Generate a random read
read <- sample(alphabet, size=n, replace = TRUE)

# Define a function counting the number of matching
# residues between two sequences
count.matches <- function(seq1, seq2) {
  return(sum(seq1==seq2))
}

dim(seq)
length(read)
# Compute alignment lengths
matches.per.seq <- apply(seq, 1, count.matches, read)

## Plot an histogram to compare the simulation results 
## and the theoretical distribution
hist(matches.per.seq, breaks=seq(from=-0.5, to=n+0.5, by=1), col="grey",
     las=1,
     main="Local alignment",
     xlab="Number of matches",
     ylab="Sequences")
x <- 0:n
lines(x, rep*dbinom(x, size = n, prob = 0.25), type="h", col="blue", lwd=3)
legend("topright", 
       c(paste(sep="", "random sequences (r=", rep, ")"),
         paste(sep="", "B(n=",n,", p=", p,")")), 
       lwd=3,
       col=c("grey", "blue"))
```

## Exercise -- binomial distribution

Draw 1000 random numbers from a binomial distribution (`rbinom()`) and compute the mean and standard deviation. 

Each student will take a custom prior probability ($p$) among the following values: $\{0.001, 0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99, 0.999\}$.



****************************************************************
# Negative binomial: local alignment with $m$ mismatches

## Waiting time for the $m^{th}$ mismatch

A local alignment algorithm starts aligning the 5' end of a read, and extends the alignment until either the $m^{th}$ mismatch or the end of the read. What is the probability to obtain by chance an alignemnt of at least $25$ nucleotides before the $4^{th}$ mismatch?

```{r negbin, echo=FALSE, fig.width=8, fig.height=7, fig.cap="Negative binomial. "}
x <- 0:25    # Number of successes

par(mfrow=c(2,2))
for (m in 1:4) {
  P.x <- dnbinom(x, size = m, prob = 0.75)
  plot(x, P.x, type="s", panel.first = grid(), ylim=c(0,1), main=paste("m = ", m))
}
par(mfrow=c(1,1))
```

## Simulated sequences


```{r random_simul_local_alignment, fig.width=7, fig.height=4, echo=FALSE}
## Simulate local alignment with random sequences. 
## Align a given read with random sequences and measure the 
## length of the longest alignment with at most m mismatches. 

# Max accepted mismatches.
m <- 5     
# Note: the alignment stops at m+1

## Define a function counting the length of the alignment 
## until the (m+1)th mismatch
ali.length <- function(seq1, seq2, max.mismatch) {
  mismatches <- which(seq1!=seq2)
  if (length(mismatches) > max.mismatch) {
    return(mismatches[max.mismatch+1]-1)
  } else {
    return (length(seq1))
  }
}

# Compute alignment lengths
ali.lengths <- apply(seq, 1, ali.length, read, m)
max.len <- max(ali.lengths)

## plot an histogram
hist(ali.lengths, breaks=seq(from=-0.5, to=max.len+1, by=1), col="grey",
     las=1,
     main="Local alignment",
     xlab="Alignment length",
     ylab="Number of sequences")
x <- 0:max.len
lines(x+m, rep*dnbinom(x, size = m+1, prob = 0.75), type="h", col="blue", lwd=3)
legend("topright", 
       c(paste("max", m, "accepted mismatches"),
         paste(sep="", "random sequences (r=", rep, ")"),
         paste(sep="", "NB(",m+1,",", 1-p,")")), 
       lwd=3,
       col=c("white", "grey", "blue"))
```


